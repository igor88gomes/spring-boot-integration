# .github/workflows/docker-publish.yaml
name: Publish Docker image

on:
  # Publicera ENDAST när kod pushas till main
  push:
    branches:
      - main
  # Möjlighet att köra manuellt vid behov
  # workflow_dispatch:

env:
  # Imagenamn för publicering till Docker Hub (publik)
  IMAGE_NAME: docker.io/igor88gomes/spring-boot-integration
  # GHCR-bild sätts senare per steg (owner i lowercase).

# Concurrency: avbryt pågående körning på samma ref (sparar minuter och resurser)
concurrency:
  group: docker-publish-${{ github.ref }}
  cancel-in-progress: true

jobs:
  publish:
    name: Bygg, skanna och publicera
    runs-on: ubuntu-latest

    # Krävs för att kunna pusha till GHCR med GITHUB_TOKEN
    permissions:
      contents: read
      packages: write
      security-events: write
      actions: write

    steps:
      # Checka ut koden
      - name: Checkout
        uses: actions/checkout@v4

      # Buildx för multi-arch builds
      - name: Ställ in Buildx
        uses: docker/setup-buildx-action@v3

      # (Valfritt) Multi-arch: QEMU för amd64/arm64
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      # Vars: kort commit-SHA (7 tecken) för taggnamn/loggar
      - name: Vars (kort SHA)
        id: vars
        shell: bash
        run: echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # Vars (GHCR owner lowercase) – krävs av GHCR
      - name: Vars (GHCR owner lowercase)
        id: ghcr_owner
        shell: bash
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      # Docker-metadata: etiketter (OCI) + håll endast :latest som publik tagg
      - name: Metadata för Docker-image
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
          labels: |
            org.opencontainers.image.title=spring-boot-integration
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      # Logga in i Docker Hub (publikt register)
      - name: Logga in i Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_ACCESS_TOKEN }}

      # Logga in i GHCR (privat staging)
      - name: Logga in i GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      # Bygg & pusha KANDIDAT till GHCR (privat) + bevara digest
      - name: Bygg & pusha kandidat (GHCR, privat)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          # Multi-arch (kan tas bort om du inte behöver arm64)
          platforms: linux/amd64,linux/arm64
          # Kandidattagg i GHCR – läsbar via kort SHA
          tags: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration:candidate-${{ steps.vars.outputs.short_sha }}
          labels: ${{ steps.meta.outputs.labels }}
          # GHCR-retention för kandidat (auto-cleanup)
          annotations: |
            org.opencontainers.image.ref.name=candidate
            ghcr.io/retention-days=14
          # GitHub cache för snabbare inkrementella builds
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Supply chain: attestation + SBOM
          provenance: mode=max
          sbom: true

      # Sårbarhetsscan av kandidaten (stoppar om CRITICAL/HIGH med fix)
      - name: Trivy scan (kandidat)
        uses: aquasecurity/trivy-action@0.33.0
        with:
          # Skanna EXAKT det som byggdes (via digest)
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          vuln-type: 'os,library'
          severity: 'CRITICAL'
          ignore-unfixed: true
          format: 'table'
          timeout: '5m'
          exit-code: '1'   # pipeline stoppar vid blockerande CVEs

      # Trivy SARIF-rapport (för Security/Code scanning)
      - name: Trivy SARIF (report)
        if: always()
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.33.0
        with:
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          scanners: 'vuln'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          format: 'sarif'
          output: 'trivy.sarif'

      - name: Upload SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy.sarif

      # Skapa SBOM-katalog (för artifact)
      - name: Skapa SBOM-katalog
        if: always()
        run: mkdir -p sbom

      # Generera en läsbar SBOM (CycloneDX) som artefakt
      - name: Generera SBOM (CycloneDX) för kandidat
        if: always()                   # kör även om spärren faller, för insyn
        continue-on-error: true        # påverkar inte spärren/promotion
        uses: aquasecurity/trivy-action@0.33.0
        with:
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          format: cyclonedx
          output: sbom/sbom.cdx.json
          ignore-unfixed: true

      - name: Ladda upp SBOM som artifact (14 dagar)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom/sbom.cdx.json
          retention-days: 14

      # Hämta provenance/attestation (in-toto/SLSA) från GHCR för samma digest och publicera som artifact
      - name: Installera cosign (för att hämta attestation)
        if: always()
        uses: sigstore/cosign-installer@v3

      # Skapa attestations-katalog (för artifact)
      - name: Skapa attestations-katalog
        if: always()
        run: mkdir -p attestations

      # Hämta provenance/attestation (in-toto)
      - name: Hämta attestation (in-toto) från GHCR
        if: always()
        continue-on-error: true
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          mkdir -p attestations

          TAG_REF=ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration:candidate-${{ steps.vars.outputs.short_sha }}
          DIGEST_REF=ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}

          # Först: tagg
          if ! cosign download attestation "$TAG_REF" > attestations/provenance.intoto.jsonl 2>/dev/null; then
            # Fallback: digest
            cosign download attestation "$DIGEST_REF" > attestations/provenance.intoto.jsonl 2>/dev/null || true
          fi

          # Säkerställ att artefakten inte är tom
          if [ ! -s attestations/provenance.intoto.jsonl ]; then
            echo '{"note":"ingen attestation hittades i GHCR för denna referens"}' > attestations/provenance.intoto.jsonl
          fi

      - name: Ladda upp attestations som artifact (14 dagar)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: attestations
          path: attestations/**
          retention-days: 14

      # Främja EXAKT samma artefakt (digest) till :latest i Docker Hub
      - name: Främja kandidat till :latest (Docker Hub)
        run: |
          docker buildx imagetools create \
            --tag ${{ env.IMAGE_NAME }}:latest \
            ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}

      # Rensning: ta bort Docker build-artefakten som skapas automatiskt.
      # Docker build-artefakten behålls om steget kommenteras bort eller tas bort.
      - name: Ta bort dockerbuild-artifact (rensning)
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const run_id = context.runId;
            const res = await github.rest.actions.listWorkflowRunArtifacts({owner, repo, run_id, per_page: 100});
            for (const a of res.data.artifacts) {
              if (a.name.includes('dockerbuild')) {
               core.info(`Deleting ${a.name} (${a.id})`);
                await github.rest.actions.deleteArtifact({owner, repo, artifact_id: a.id});
              }
            }
