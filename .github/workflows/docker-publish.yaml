# .github/workflows/docker-publish.yaml
name: Publish Docker image

on:
  # Publicera ENDAST när kod pushas till main
  push:
    branches:
      - main
  # Möjlighet att köra manuellt vid behov
  # workflow_dispatch:

env:
  # Imagenamn för publicering till Docker Hub (publik)
  IMAGE_NAME: docker.io/igor88gomes/spring-boot-integration
  # GHCR-bild sätts senare per steg (owner i lowercase).

# Concurrency: avbryt pågående körning på samma ref (sparar minuter och resurser)
concurrency:
  group: docker-publish-${{ github.ref }}
  cancel-in-progress: true

jobs:
  publish:
    name: Bygg, skanna och publicera
    runs-on: ubuntu-latest

    # Krävs för att kunna pusha till GHCR med GITHUB_TOKEN
    permissions:
      contents: read
      packages: write
      security-events: write

    steps:
      # Checka ut koden
      - name: Checkout
        uses: actions/checkout@v4

      # Buildx för multi-arch builds
      - name: Ställ in Buildx
        uses: docker/setup-buildx-action@v3

      # (Valfritt) Multi-arch: QEMU för amd64/arm64
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      # Vars: kort commit-SHA (7 tecken) för taggnamn/loggar
      - name: Vars (kort SHA)
        id: vars
        shell: bash
        run: echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # Vars (GHCR owner lowercase) – krävs av GHCR
      - name: Vars (GHCR owner lowercase)
        id: ghcr_owner
        shell: bash
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      # Docker-metadata: etiketter (OCI) + håll endast :latest som publik tagg
      - name: Metadata för Docker-image
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
          labels: |
            org.opencontainers.image.title=spring-boot-integration
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      # Logga in i Docker Hub (publikt register)
      - name: Logga in i Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_ACCESS_TOKEN }}

      # Logga in i GHCR (privat staging)
      - name: Logga in i GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      # Bygg & pusha KANDIDAT till GHCR (privat) + bevara digest
      - name: Bygg & pusha kandidat (GHCR, privat)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          # Multi-arch (behåll för x86_64 + Apple Silicon)
          platforms: linux/amd64,linux/arm64
          # Kandidattagg i GHCR – läsbar via kort SHA
          tags: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration:candidate-${{ steps.vars.outputs.short_sha }}
          labels: ${{ steps.meta.outputs.labels }}
          # GHCR-retention för kandidat (auto-cleanup)
          annotations: |
            org.opencontainers.image.ref.name=candidate
            ghcr.io/retention-days=14
          # GitHub cache för snabbare inkrementella builds
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Attestation/SBOM-inbäddning avaktiverad – vi publicerar läsbar SBOM som artifact nedan
          provenance: false
          sbom: false

      # Trivy: cache av databas för snabbare körning (rotateras veckovis)
      - name: Veckonyckel för Trivy-cache
        id: wk
        run: echo "value=$(date -u +%G-%V)" >> "$GITHUB_OUTPUT"

      - name: Cache Trivy DB
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: ${{ runner.os }}-trivy-db-v2-${{ steps.wk.outputs.value }}
          restore-keys: ${{ runner.os }}-trivy-db-v2-

      # Sårbarhetsscan av kandidaten (stoppar om CRITICAL)
      - name: Trivy scan (kandidat)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          # Skanna EXAKT det som byggdes (via digest)
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          vuln-type: 'os,library'
          severity: 'CRITICAL'
          ignore-unfixed: true
          format: 'table'
          timeout: '5m'
          exit-code: '1'   # pipeline stoppar vid blockerande CVEs

      # Trivy SARIF-rapport (för Security/Code scanning)
      - name: Trivy SARIF (report)
        if: always()
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          scanners: 'vuln'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          format: 'sarif'
          output: 'trivy.sarif'

      - name: Upload SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy.sarif

      # --- CD-artifacts (SBOM) för Actions ---
      # Skapa SBOM-katalog (för artifact)
      - name: Skapa SBOM-katalog
        if: always()
        run: mkdir -p sbom

      # Generera en läsbar SBOM (CycloneDX) som artifact som kan laddas ner direkt från Actions
      - name: Generera SBOM (CycloneDX) för kandidat
        if: always()                   # kör även om spärren faller, för insyn
        continue-on-error: true        # påverkar inte spärren/promotion
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          format: cyclonedx
          output: sbom/sbom.cdx.json
          ignore-unfixed: true

      # Kontrollera SBOM
      - name: Kontrollera SBOM (CycloneDX)
        id: sbom_check
        if: always()
        run: |
          if [ -s sbom/sbom.cdx.json ] && jq -e '.bomFormat=="CycloneDX"' sbom/sbom.cdx.json >/dev/null 2>&1; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Ladda upp SBOM som artifact (14 dagar)
        if: always() && steps.sbom_check.outputs.has == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom/sbom.cdx.json
          retention-days: 14

      - name: Hoppa över upload (SBOM saknas/ogiltig)
        if: always() && steps.sbom_check.outputs.has != 'true'
        run: echo "SBOM saknas/ogiltig; hoppar över upload."

      # Främja EXAKT samma artefakt (digest) till :latest i Docker Hub
      - name: Främja kandidat till :latest (Docker Hub)
        run: |
          docker buildx imagetools create \
            --tag ${{ env.IMAGE_NAME }}:latest \
            ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}

  # Separat jobb: rensa Docker Desktop build record-artefakt (för att undvika förvirring)
  cleanup:
    name: Rensa artifacts (dockerbuild)
    needs: publish
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Ta bort dockerbuild-artifact
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const run_id = context.runId;
            const res = await github.rest.actions.listWorkflowRunArtifacts({owner, repo, run_id, per_page: 100});
            for (const a of res.data.artifacts) {
              if (a.name.includes('dockerbuild')) {
                core.info(`Deleting ${a.name} (${a.id})`);
                await github.rest.actions.deleteArtifact({owner, repo, artifact_id: a.id});
              }
            }
