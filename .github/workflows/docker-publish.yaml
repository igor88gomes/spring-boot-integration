# .github/workflows/docker-publish.yaml
name: Publish Docker image

on:
  # Publicera ENDAST när kod pushas till main
  push:
    branches:
      - main
  # Möjlighet att köra manuellt vid behov
  # workflow_dispatch:

env:
  # Imagenamn för publicering till Docker Hub (publik)
  IMAGE_NAME: docker.io/igor88gomes/spring-boot-integration
  # GHCR-bild sätts senare per steg (owner i lowercase).

# Concurrency: avbryt pågående körning på samma ref (sparar minuter och resurser)
concurrency:
  group: docker-publish-${{ github.ref }}
  cancel-in-progress: true

jobs:
  publish:
    name: Bygg, skanna och publicera
    runs-on: ubuntu-latest

    # Krävs för att kunna pusha till GHCR med GITHUB_TOKEN
    permissions:
      contents: read
      packages: write
      security-events: write
      actions: write
      id-token: write
      attestations: write

    steps:
      # Checka ut koden
      - name: Checkout
        uses: actions/checkout@v4

      # Buildx för multi-arch builds
      - name: Ställ in Buildx
        uses: docker/setup-buildx-action@v3

      # (Valfritt) Multi-arch: QEMU för amd64/arm64
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3

      # Vars: kort commit-SHA (7 tecken) för taggnamn/loggar
      - name: Vars (kort SHA)
        id: vars
        shell: bash
        run: echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # Vars (GHCR owner lowercase) – krävs av GHCR
      - name: Vars (GHCR owner lowercase)
        id: ghcr_owner
        shell: bash
        run: echo "owner_lc=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      # Docker-metadata: etiketter (OCI) + håll endast :latest som publik tagg
      - name: Metadata för Docker-image
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
          labels: |
            org.opencontainers.image.title=spring-boot-integration
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      # Logga in i Docker Hub (publikt register)
      - name: Logga in i Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_ACCESS_TOKEN }}

      # Logga in i GHCR (privat staging)
      - name: Logga in i GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      # Bygg & pusha KANDIDAT till GHCR (privat) + bevara digest
      - name: Bygg & pusha kandidat (GHCR, privat)
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          # Multi-arch (kan tas bort om du inte behöver arm64)
          platforms: linux/amd64,linux/arm64
          # Kandidattagg i GHCR – läsbar via kort SHA
          tags: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration:candidate-${{ steps.vars.outputs.short_sha }}
          labels: ${{ steps.meta.outputs.labels }}
          # GHCR-retention för kandidat (auto-cleanup)
          annotations: |
            org.opencontainers.image.ref.name=candidate
            ghcr.io/retention-days=14
          # GitHub cache för snabbare inkrementella builds
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Buildx-provenance/attach inaktiveras här – vi använder cosign nedan
          provenance: false
          sbom: false

      # Sårbarhetsscan av kandidaten (stoppar om CRITICAL)
      - name: Trivy scan (kandidat)
        uses: aquasecurity/trivy-action@0.33.0
        with:
          # Skanna EXAKT det som byggdes (via digest)
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          vuln-type: 'os,library'
          severity: 'CRITICAL'
          ignore-unfixed: true
          format: 'table'
          timeout: '5m'
          exit-code: '1'   # pipeline stoppar vid blockerande CVEs

      # Trivy SARIF-rapport (för Security/Code scanning)
      - name: Trivy SARIF (report)
        if: always()
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.33.0
        with:
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          scanners: 'vuln'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true
          format: 'sarif'
          output: 'trivy.sarif'

      - name: Upload SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy.sarif

      # --- SBOM som artefakt (rekryterar-vänligt) ---
      - name: Skapa SBOM-katalog
        if: always()
        run: mkdir -p sbom

      - name: Generera SBOM (CycloneDX) för kandidat
        if: always()
        continue-on-error: false
        uses: aquasecurity/trivy-action@0.33.0
        with:
          image-ref: ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}
          format: cyclonedx
          output: sbom/sbom.cdx.json
          ignore-unfixed: true

      - name: Ladda upp SBOM som artifact (14 dagar)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom/sbom.cdx.json
          retention-days: 14

      # --- Attestation via cosign (keyless) — oberoende av GitHub Attestations API ---
      # Installera cosign
      - name: Installera cosign (för att bifoga/hämta attestation)
        if: always()
        uses: sigstore/cosign-installer@v3

      # Logga in i GHCR (cosign push kräver auth till registry)
      - name: Logga in i GHCR för cosign
        if: always()
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          echo "${{ github.token }}" | cosign login ghcr.io -u "${{ github.actor }}" --password-stdin

      # Skapa och bifoga en minimal SLSA-proveniens som OCI-referrer till exakt digest
      - name: Bifoga provenance (in-toto/SLSA) till GHCR (cosign keyless)
        if: always()
        continue-on-error: true          # valfritt: påverkar inte publicering om något faller här
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}"

          cat > provenance.json <<'JSON'
          {
            "_type": "https://in-toto.io/Statement/v0.1",
            "predicateType": "https://slsa.dev/provenance/v1",
            "subject": [],
            "predicate": {
              "buildType": "https://slsa-framework.github.io/github-actions-buildtypes/workflow/v1",
              "builder": { "id": "https://github.com/actions/runner" }
            }
          }
          JSON

          # Keyless-signering via OIDC; bifogar som OCI-referrer till IMAGE
          cosign attest --yes --keyless --predicate provenance.json --type slsaprovenance "$IMAGE"

      # Skapa attestations-katalog (för artifact)
      - name: Skapa attestations-katalog
        if: always()
        run: mkdir -p attestations

      # Hämta attestation (nu från GHCR – den som just bifogades)
      - name: Hämta attestation (in-toto) från GHCR (cosign download)
        if: always()
        continue-on-error: true          # valfritt: pipeline ska inte falla om registry/väg svarar sent
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}"
          cosign download attestation "$IMAGE" > attestations/provenance.intoto.jsonl

      # Kontroll: publicera endast om filen innehåller ett signerat payload (predicateType).
      - name: Kontrollera att attestation innehåller payload
        id: attest_check
        if: always()
        run: |
          if grep -q '"predicateType"' attestations/provenance.intoto.jsonl 2>/dev/null; then
            echo "has=true" >> "$GITHUB_OUTPUT"
          else
            echo "has=false" >> "$GITHUB_OUTPUT"
          fi

      # Ladda upp attestations som artifact (14 dagar) – bara när payload finns.
      - name: Ladda upp attestations som artifact (14 dagar)
        if: always() && steps.attest_check.outputs.has == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: attestations
          path: attestations/**
          retention-days: 14

      # Logg om upload hoppas över
      - name: Hoppa över upload (ingen attestation hittades)
        if: always() && steps.attest_check.outputs.has != 'true'
        run: echo "Ingen attestation hittades; hoppar över upload."

      # Främja EXAKT samma artefakt (digest) till :latest i Docker Hub
      - name: Främja kandidat till :latest (Docker Hub)
        run: |
          docker buildx imagetools create \
            --tag ${{ env.IMAGE_NAME }}:latest \
            ghcr.io/${{ steps.ghcr_owner.outputs.owner_lc }}/spring-boot-integration@${{ steps.build.outputs.digest }}

  cleanup:
    name: Rensa artifacts (dockerbuild)
    needs: publish
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: Ta bort dockerbuild-artifact
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const run_id = context.runId;
            const res = await github.rest.actions.listWorkflowRunArtifacts({owner, repo, run_id, per_page: 100});
            for (const a of res.data.artifacts) {
              if (a.name.includes('dockerbuild')) {
                core.info(`Deleting ${a.name} (${a.id})`);
                await github.rest.actions.deleteArtifact({owner, repo, artifact_id: a.id});
              }
            }
